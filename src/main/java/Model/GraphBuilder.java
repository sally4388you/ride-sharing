package Model;

import com.opencsv.bean.CsvToBeanBuilder;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultEdge;
import org.jgrapht.graph.SimpleDirectedGraph;
import org.json.JSONArray;

import java.awt.geom.Point2D;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.*;

/**
 * Class GraphBuilder: help build org.jgrapht.Graph from the original trips data
 *
 * author: Sally Qi
 * date: 2019/05/12
 */
public class GraphBuilder
{
    private ArrayList<Vertex> vertices; // map original trips data to an array of vertex
    private Map<Point2D.Double, Set<Integer>> vertices_tmp; // a temporary variable to help build the graph
//    private Vertex destination; // destination vertex

    /**âˆ‚
     * @return an array of vertex that contains information of trip and its id
     */
    public ArrayList<Vertex> getVertices() {
        return vertices;
    }

    /**
     * Initialize the graph build from a csv file
     *
     * @param url csv file location
     * @throws FileNotFoundException throw error if the file doesn't exist
     */
    public GraphBuilder(String url) throws FileNotFoundException
    {
        FileReader reader = new FileReader(new File(url).getAbsolutePath());

        @SuppressWarnings("unchecked")
        List<Trip> trips = new CsvToBeanBuilder(reader).withType(Trip.class).build().parse();

        Point2D.Double destination = null;

        this.vertices = new ArrayList<>();
        this.vertices_tmp = new HashMap<>();

        int total = 0;
        for (Trip trip : trips) {

            // abandon trips that doesn't have the same destination
            String destLat = trip.getMapEndLat();
            String destLng = trip.getMapEndLng();

            Point2D.Double this_dest = new Point2D.Double(Double.valueOf(destLng), Double.valueOf(destLat));

            if (destination == null) destination = this_dest;
            if (!this_dest.equals(destination)) continue;

            // start creating vertices
            String sourceLat = trip.getMapStartLat();
            String sourceLng = trip.getMapStartLng();

            Point2D.Double source = new Point2D.Double(Double.valueOf(sourceLng), Double.valueOf(sourceLat));
            Vertex vertex = new Vertex(total, trip);

            Set<Integer> set = this.vertices_tmp.containsKey(source) ? this.vertices_tmp.get(source) : new HashSet<>();
            set.add(total);

            this.vertices.add(vertex);
            this.vertices_tmp.put(source, set);
            total++;
        }
//        this.destination = new Vertex(total, destination, null);

    }

    /**
     * Build org.jgrapht.Graph from a csv file
     *
     * @return org.jgrapht.Graph
     */
    public Graph getSimpleDirectedGraph()
    {
        Graph<Integer, DefaultEdge> graph = new SimpleDirectedGraph<>(DefaultEdge.class);

        Set<Integer> visited = new HashSet<>();

        Map<Float, Integer> sortGraphByLength = new TreeMap<>(Collections.reverseOrder());

        // partitioned into same group if having same source
        this.vertices.forEach(
            vertex -> sortGraphByLength.putIfAbsent(vertex.getTrip().getLength(), vertex.getId())
        );

        // compute Hr
        // from shorter to longer in terms of path length
        // the former, the shorter
        for(Integer vertex_id : sortGraphByLength.values()) {
            if (visited.contains(vertex_id)) continue;

            // mark vertex as visited
            visited.add(vertex_id);

            // path generated by map API, contains every single important coordinate
            JSONArray path = this.vertices.get(vertex_id).getTrip().getPath();

            // add this vertex to the graph and mark the vertex as the first vertex
            graph.addVertex(vertex_id);
            Integer last_vertex = vertex_id;

            // traverse the path from nearer point to further point until destination
            for (int i = 0; i < path.length() - 2; i ++) {
                JSONArray pathVertex = path.getJSONArray(i);
                double lng = pathVertex.getDouble(0);
                double lat = pathVertex.getDouble(1);

                Point2D.Double location_on_the_way = new Point2D.Double(lng, lat);

                // search if the point is source of one of the trips
                if (this.vertices_tmp.containsKey(location_on_the_way)) {

                    Set<Integer> vertices_on_the_way = this.vertices_tmp.get(location_on_the_way);

                    // add edges for found trips and the current trip
                    for (Integer vertex_on_the_way : vertices_on_the_way) {
                        if (vertex_id.equals(vertex_on_the_way)) continue;

                        // add the vertex and an edge
                        graph.addVertex(vertex_on_the_way);
                        graph.addEdge(last_vertex, vertex_on_the_way);

                        // change the tail vertex
                        last_vertex = vertex_on_the_way;
                        // mark vertex as visited
                        visited.add(vertex_on_the_way);
                    }
                }
            }

            // add an edge between the current trip and its destination
//            graph.addVertex(this.destination.getId());
//            graph.addEdge(last_vertex, this.destination.getId());
        }

        return graph;
    }
}
